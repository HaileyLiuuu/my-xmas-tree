<!DOCTYPE html><html lang="zh-CN"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ethereal Xmas - Synchronized Flow</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Optima', 'PingFang SC', sans-serif; }
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; display: flex; flex-direction: column; align-items: center; }
        #top-hint { position: absolute; top: 3%; width: 100%; text-align: center; color: #ffb6c1; font-size: 0.85rem; letter-spacing: 4px; text-shadow: 0 0 10px rgba(0,0,0,0.9); }
        
        /* 按钮容器：放置在底部 */
        #btn-group { position: absolute; bottom: 12%; display: flex; gap: 15px; pointer-events: auto; }
        
        .magic-btn { 
            padding: 14px 25px; font-size: 0.9rem; letter-spacing: 2px; 
            background: rgba(255, 182, 193, 0.1); border: 1px solid rgba(255, 182, 193, 0.4); 
            backdrop-filter: blur(8px); border-radius: 4px; cursor: pointer; 
            color: #ffb6c1; font-weight: 300; transition: 0.6s; 
        }
        .magic-btn:hover { background: rgba(255, 182, 193, 0.2); border-color: #ffb6c1; }
        
        #video-container { position: fixed; bottom: 20px; right: 20px; width: 120px; height: 90px; border-radius: 4px; overflow: hidden; border: 1px solid rgba(255,182,193,0.2); opacity: 0; transition: 1s; }
    </style></head><body><audio id="bg-music" loop>
    <source src="https://cdn.jsdelivr.net/gh/HaileyLiuuu/my-xmas-tree/jingleBellRock.mp3" type="audio/mpeg"></audio><div id="ui-layer">
    <div id="top-hint">
        <h1 style="font-weight: 200; margin: 0; font-size: 3rem;">Merry Christmas</h1>
        <p style="opacity: 0.7; margin: 5px 0;">张开手掌：粒子散开 | 握拳：看到圣诞树</p>
    </div>
    
    <div id="btn-group">
        <button id="start-btn" class="magic-btn">开启魔法交互</button>
        <button id="music-toggle" class="magic-btn" style="display: none;">Music: ON</button>
    </div>
</div><div id="video-container">
    <video id="webcam" autoplay playsinline style="width:100%; height:100%; object-fit: cover; transform: scaleX(-1);"></video></div><script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }</script><script type="module">import * as THREE from 'three';import { GestureRecognizer, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";let scene, camera, renderer, treeParticles, spaceDust, heartPoints;let gestureRecognizer;let isExploded = false;const webcam = document.getElementById('webcam');const treeParticleCount = 45000;const heartParticleCount = 4000;const treePos = [], treeTargets = [], treeColors = [];const heartPos = [], heartTargets = [], heartExplodeTargets = [], heartColors = [];function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.0, 18);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const commonTexture = createCircleTexture();
    const sharedColorsArr = [
        new THREE.Color(0xff1493), new THREE.Color(0xff69b4),
        new THREE.Color(0xdb7093), new THREE.Color(0xffc0cb)
    ];
    const goldColor = new THREE.Color(0xd4af37);

    const heartGeo = new THREE.BufferGeometry();
    const hScale = 0.06;
    for (let i = 0; i < heartParticleCount; i++) {
        const t = Math.random() * Math.PI * 2;
        const r = Math.sqrt(Math.random()); 
        const x = r * (16 * Math.pow(Math.sin(t), 3));
        const y = r * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
        const tx = x * hScale;
        const ty = (y * hScale) + 6.3;
        const tz = (Math.random() - 0.5) * 0.7;
        heartTargets.push(tx, ty, tz);
        heartPos.push(tx, ty, tz);
        heartExplodeTargets.push((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60);
        const isGold = Math.random() < 0.30;
        const c = isGold ? goldColor : sharedColorsArr[Math.floor(Math.random() * sharedColorsArr.length)];
        heartColors.push(c.r, c.g, c.b);
    }
    heartGeo.setAttribute('position', new THREE.Float32BufferAttribute(heartPos, 3));
    heartGeo.setAttribute('color', new THREE.Float32BufferAttribute(heartColors, 3));
    heartPoints = new THREE.Points(heartGeo, new THREE.PointsMaterial({
        size: 0.11, vertexColors: true, transparent: true, opacity: 0.95, 
        blending: THREE.AdditiveBlending, map: commonTexture, depthWrite: false
    }));
    scene.add(heartPoints);

    const coneGeo = new THREE.BufferGeometry();
    for (let i = 0; i < treeParticleCount; i++) {
        const t = Math.random(); 
        const angle = Math.random() * Math.PI * 2;
        const radius = (1 - t) * 4.5;
        const x = radius * Math.cos(angle);
        const y = t * 12 - 6;
        const z = radius * Math.sin(angle);
        treePos.push(x, y, z);
        treeTargets.push((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60);
        const c = sharedColorsArr[Math.floor(Math.random() * sharedColorsArr.length)];
        treeColors.push(c.r, c.g, c.b);
    }
    coneGeo.setAttribute('position', new THREE.Float32BufferAttribute(treePos, 3));
    coneGeo.setAttribute('color', new THREE.Float32BufferAttribute(treeColors, 3));
    treeParticles = new THREE.Points(coneGeo, new THREE.PointsMaterial({
        size: 0.14, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending,
        map: commonTexture, depthWrite: false, opacity: 0.65
    }));
    scene.add(treeParticles);

    const dustGeo = new THREE.BufferGeometry();
    const dPos = [], dColorsArr = [];
    for(let i=0; i<3500; i++) {
        dPos.push((Math.random()-0.5)*120, (Math.random()-0.5)*120, (Math.random()-0.5)*120);
        const c = Math.random() > 0.2 ? goldColor : new THREE.Color(0xffffff);
        dColorsArr.push(c.r, c.g, c.b);
    }
    dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dPos, 3));
    dustGeo.setAttribute('color', new THREE.Float32BufferAttribute(dColorsArr, 3));
    spaceDust = new THREE.Points(dustGeo, new THREE.PointsMaterial({ size: 0.1, vertexColors: true, transparent: true, opacity: 0.35, blending: THREE.AdditiveBlending }));
    scene.add(spaceDust);

    animate();
}function createCircleTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
    grad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 64, 64);
    return new THREE.CanvasTexture(canvas);
}function animate() {
    requestAnimationFrame(animate);
    const time = Date.now() * 0.001;
    const lerpSpeed = 0.06;

    const tPosAttr = treeParticles.geometry.attributes.position;
    for (let i = 0; i < treeParticleCount; i++) {
        let idx = i * 3;
        const t = (tPosAttr.array[idx+1] + 6) / 12;
        const swirl = Math.sin(time + t * 4) * 0.04;
        for(let j=0; j<3; j++) {
            const origin = treePos[idx+j] + (j!==1 ? swirl : 0);
            const target = isExploded ? treeTargets[idx+j] : origin;
            tPosAttr.array[idx+j] += (target - tPosAttr.array[idx+j]) * lerpSpeed;
        }
    }
    tPosAttr.needsUpdate = true;
    treeParticles.rotation.y += 0.0015;

    const hPosAttr = heartPoints.geometry.attributes.position;
    const hScaleActive = 1.0 + Math.sin(time * 3.5) * 0.08;
    for (let i = 0; i < heartParticleCount; i++) {
        let idx = i * 3;
        const originX = heartTargets[idx] * hScaleActive;
        const originY = (heartTargets[idx+1] - 6.3) * hScaleActive + 6.3;
        const originZ = heartTargets[idx+2] * hScaleActive;
        const targetX = isExploded ? heartExplodeTargets[idx] : originX;
        const targetY = isExploded ? heartExplodeTargets[idx+1] : originY;
        const targetZ = isExploded ? heartExplodeTargets[idx+2] : originZ;
        hPosAttr.array[idx] += (targetX - hPosAttr.array[idx]) * lerpSpeed;
        hPosAttr.array[idx+1] += (targetY - hPosAttr.array[idx+1]) * lerpSpeed;
        hPosAttr.array[idx+2] += (targetZ - hPosAttr.array[idx+2]) * lerpSpeed;
    }
    hPosAttr.needsUpdate = true;
    heartPoints.rotation.y += 0.015;

    spaceDust.rotation.y += 0.0003;
    renderer.render(scene, camera);
}async function startAI() {
    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
    gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
        baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task" },
        runningMode: "VIDEO", numHands: 1
    });
    tick();
}function tick() {
    if (gestureRecognizer && webcam.currentTime !== -1) {
        const res = gestureRecognizer.recognizeForVideo(webcam, performance.now());
        if (res.gestures.length > 0) {
            const name = res.gestures[0][0].categoryName;
            isExploded = (name === "Open_Palm");
        }
    }
    requestAnimationFrame(tick);
}

// 获取控制元素
const music = document.getElementById('bg-music');
const startBtn = document.getElementById('start-btn');
const musicToggle = document.getElementById('music-toggle');

// 音乐开关切换逻辑
musicToggle.onclick = () => {
    if (music.paused) {
        music.play();
        musicToggle.innerText = "Music: ON";
    } else {
        music.pause();
        musicToggle.innerText = "Music: OFF";
    }
};

// 按钮点击逻辑：开启摄像头、AI识别并同步响起音乐
startBtn.onclick = async () => {
    try {
        music.play(); // 刚开启魔法时，自动播放音乐
        
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        webcam.srcObject = stream;
        document.getElementById('video-container').style.opacity = '1';
        
        await startAI();
        
        // 开启成功后：隐藏“开启”按钮，显示“音乐开关”按钮
        startBtn.style.display = 'none';
        musicToggle.style.display = 'block';
    } catch (e) { 
        alert("开启魔法需要摄像头权限及网络加载资源"); 
        console.error(e);
    }
};

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

init();</script></body></html>
