<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ethereal Xmas - Mobile Magic</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: space-between; }
        
        #top-hint { margin-top: 15%; width: 90%; text-align: center; color: #ffb6c1; text-shadow: 0 0 10px rgba(0,0,0,0.8); }
        h1 { font-weight: 200; margin: 0; font-size: 2.2rem; letter-spacing: 2px; }
        p { opacity: 0.8; margin: 8px 0; font-size: 0.8rem; line-height: 1.4; }

        /* æŒ‰é’®å®¹å™¨ï¼šå¹¶æ’æ’åˆ— */
        #controls { margin-bottom: 20%; pointer-events: auto; display: flex; gap: 15px; align-items: center; }

        .glass-btn { 
            padding: 16px 24px; font-size: 0.9rem; letter-spacing: 1px; 
            background: rgba(255, 182, 193, 0.15); border: 1px solid rgba(255, 182, 193, 0.4); 
            backdrop-filter: blur(10px); border-radius: 50px; cursor: pointer; 
            color: #ffb6c1; transition: 0.3s; -webkit-tap-highlight-color: transparent;
        }

        #start-btn { padding: 16px 32px; font-weight: bold; background: rgba(255, 182, 193, 0.25); }
        
        #music-toggle { width: 100px; font-size: 0.8rem; }

        #video-container { 
            position: fixed; top: 20px; right: 20px; width: 80px; height: 100px; 
            border-radius: 12px; overflow: hidden; border: 1.5px solid rgba(255,182,193,0.4); 
            opacity: 0; transition: 1s; z-index: 90;
        }
    </style>
</head>
<body>

<audio id="bg-music" loop playsinline>
    <source src="https://cdn.jsdelivr.net/gh/HaileyLiuuu/my-xmas-tree/jingleBellRock.mp3" type="audio/mpeg">
</audio>

<div id="ui-layer">
    <div id="top-hint">
        <h1>Merry Christmas</h1>
        <p>å¼ å¼€æ‰‹æŒï¼šæ•£å¼€ç²’å­<br>ç´§æ¡æ‹³å¤´ï¼šå‡èšå¿ƒæ„¿</p>
    </div>
    
    <div id="controls">
        <button id="start-btn" class="glass-btn">å¼€å¯åœ£è¯é­”æ³•</button>
        <button id="music-toggle" class="glass-btn">ğŸµ ON</button>
    </div>
</div>

<div id="video-container">
    <video id="webcam" autoplay playsinline muted style="width:100%; height:100%; object-fit: cover; transform: scaleX(-1);"></video>
</div>

<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
import * as THREE from 'three';
import { GestureRecognizer, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
let scene, camera, renderer, treeParticles, spaceDust, heartPoints;
let gestureRecognizer;
let isExploded = false;
let musicPlaying = false;

const webcam = document.getElementById('webcam');
const music = document.getElementById('bg-music');
const musicBtn = document.getElementById('music-toggle');

const treeParticleCount = isMobile ? 15000 : 40000; 
const heartParticleCount = isMobile ? 2000 : 4000;
const treePos = [], treeTargets = [], treeColors = [];
const heartPos = [], heartTargets = [], heartExplodeTargets = [], heartColors = [];

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.0, isMobile ? 22 : 18);

    renderer = new THREE.WebGLRenderer({ antialias: !isMobile });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const commonTexture = createCircleTexture();
    const sharedColorsArr = [new THREE.Color(0xff1493), new THREE.Color(0xff69b4), new THREE.Color(0xdb7093), new THREE.Color(0xffc0cb)];
    const goldColor = new THREE.Color(0xd4af37);

    // 1. å¿ƒå½¢
    const heartGeo = new THREE.BufferGeometry();
    const hScale = isMobile ? 0.05 : 0.06;
    for (let i = 0; i < heartParticleCount; i++) {
        const t = Math.random() * Math.PI * 2, r = Math.sqrt(Math.random()); 
        const x = r * (16 * Math.pow(Math.sin(t), 3)), y = r * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
        heartTargets.push(x * hScale, (y * hScale) + 6.3, (Math.random() - 0.5) * 0.7);
        heartPos.push(x * hScale, (y * hScale) + 6.3, (Math.random() - 0.5) * 0.7);
        heartExplodeTargets.push((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
        const c = Math.random() < 0.3 ? goldColor : sharedColorsArr[Math.floor(Math.random() * sharedColorsArr.length)];
        heartColors.push(c.r, c.g, c.b);
    }
    heartGeo.setAttribute('position', new THREE.Float32BufferAttribute(heartPos, 3));
    heartGeo.setAttribute('color', new THREE.Float32BufferAttribute(heartColors, 3));
    heartPoints = new THREE.Points(heartGeo, new THREE.PointsMaterial({ size: 0.12, vertexColors: true, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, map: commonTexture, depthWrite: false }));
    scene.add(heartPoints);

    // 2. åœ£è¯æ ‘
    const coneGeo = new THREE.BufferGeometry();
    for (let i = 0; i < treeParticleCount; i++) {
        const t = Math.random(), angle = Math.random() * Math.PI * 2, radius = (1 - t) * 4.5;
        treePos.push(radius * Math.cos(angle), t * 12 - 6, radius * Math.sin(angle));
        treeTargets.push((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
        const c = sharedColorsArr[Math.floor(Math.random() * sharedColorsArr.length)];
        treeColors.push(c.r, c.g, c.b);
    }
    coneGeo.setAttribute('position', new THREE.Float32BufferAttribute(treePos, 3));
    coneGeo.setAttribute('color', new THREE.Float32BufferAttribute(treeColors, 3));
    treeParticles = new THREE.Points(coneGeo, new THREE.PointsMaterial({ size: 0.15, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending, map: commonTexture, depthWrite: false, opacity: 0.6 }));
    scene.add(treeParticles);

    // 3. æ˜Ÿå°˜
    const dustGeo = new THREE.BufferGeometry();
    const dPos = [];
    for(let i=0; i<(isMobile?1000:3000); i++) dPos.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
    dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dPos, 3));
    spaceDust = new THREE.Points(dustGeo, new THREE.PointsMaterial({ size: 0.08, color: 0xffffff, transparent: true, opacity: 0.3 }));
    scene.add(spaceDust);

    animate();
}

function createCircleTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 32; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
    grad.addColorStop(0, '#fff'); grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad; ctx.fillRect(0, 0, 32, 32);
    return new THREE.CanvasTexture(canvas);
}

function animate() {
    requestAnimationFrame(animate);
    const time = Date.now() * 0.001;
    const lerpSpeed = isMobile ? 0.08 : 0.06;

    const tPosAttr = treeParticles.geometry.attributes.position;
    for (let i = 0; i < treeParticleCount; i++) {
        let idx = i * 3;
        for(let j=0; j<3; j++) {
            const target = isExploded ? treeTargets[idx+j] : treePos[idx+j];
            tPosAttr.array[idx+j] += (target - tPosAttr.array[idx+j]) * lerpSpeed;
        }
    }
    tPosAttr.needsUpdate = true;
    treeParticles.rotation.y += 0.002;

    const hPosAttr = heartPoints.geometry.attributes.position;
    const hPulse = 1.0 + Math.sin(time * 3) * 0.1;
    for (let i = 0; i < heartParticleCount; i++) {
        let idx = i * 3;
        for(let j=0; j<3; j++) {
            const origin = heartTargets[idx+j] * hPulse;
            const target = isExploded ? heartExplodeTargets[idx+j] : origin;
            hPosAttr.array[idx+j] += (target - hPosAttr.array[idx+j]) * lerpSpeed;
        }
    }
    hPosAttr.needsUpdate = true;
    heartPoints.rotation.y += 0.01;
    renderer.render(scene, camera);
}

async function startAI() {
    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
    gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
        baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task" },
        runningMode: "VIDEO", numHands: 1
    });
    tick();
}

function tick() {
    if (gestureRecognizer && webcam.readyState >= 2) {
        const res = gestureRecognizer.recognizeForVideo(webcam, performance.now());
        if (res.gestures.length > 0) {
            isExploded = (res.gestures[0][0].categoryName === "Open_Palm");
        }
    }
    requestAnimationFrame(tick);
}

// éŸ³ä¹æ§åˆ¶é€»è¾‘
function toggleMusic() {
    if (music.paused) {
        music.play();
        musicBtn.innerText = "ğŸµ ON";
        musicPlaying = true;
    } else {
        music.pause();
        musicBtn.innerText = "ğŸ”‡ OFF";
        musicPlaying = false;
    }
}

musicBtn.onclick = (e) => {
    e.stopPropagation();
    toggleMusic();
};

document.getElementById('start-btn').onclick = async () => {
    const btn = document.getElementById('start-btn');
    btn.innerText = "é­”æ³•åŠ è½½ä¸­...";
    try {
        // åˆå§‹è‡ªåŠ¨æ’­æ”¾éŸ³ä¹
        music.play();
        musicPlaying = true;
        musicBtn.innerText = "ğŸµ ON";

        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: "user", width: isMobile ? 240 : 640 } 
        });
        webcam.srcObject = stream;
        document.getElementById('video-container').style.opacity = '1';
        await startAI();
        btn.style.display = 'none';
    } catch (e) { 
        alert("è¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å¼€å¯æ‘„åƒå¤´æƒé™ï¼Œå¹¶ä½¿ç”¨ HTTPS è®¿é—®");
    }
};

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

init();
</script>
</body>
</html>
